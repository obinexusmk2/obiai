/* polycall.c - OBINexus v2 Core Implementation */

#include "libpolycall/core/polycall.h"
#include "libpolycall/core/types.h"
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#define POLYCALL_VERSION "2.0.0"
#define MAX_ERROR_LENGTH 256

/* Internal context structure - opaque to API users */
struct polycall_context {
    char last_error[MAX_ERROR_LENGTH];
    void* user_data;
    size_t memory_pool_size;
    unsigned int flags;
    bool is_initialized;
    pthread_mutex_t lock;
};

/* Static helper functions */
static void set_error(polycall_context_t ctx, const char* error) {
    if (ctx && error) {
        strncpy(ctx->last_error, error, MAX_ERROR_LENGTH - 1);
        ctx->last_error[MAX_ERROR_LENGTH - 1] = '\0';
    }
}

/* API Implementation */

polycall_status_t polycall_init_with_config(
    polycall_context_t* ctx,
    const polycall_config_t* config
) {
    if (!ctx) {
        return POLYCALL_ERROR_INVALID_PARAMETERS;
    }

    /* Allocate context */
    struct polycall_context* new_ctx = calloc(1, sizeof(struct polycall_context));
    if (!new_ctx) {
        return POLYCALL_ERROR_OUT_OF_MEMORY;
    }

    /* Initialize mutex */
    if (pthread_mutex_init(&new_ctx->lock, NULL) != 0) {
        free(new_ctx);
        return POLYCALL_ERROR_UNKNOWN;
    }

    /* Initialize with defaults */
    new_ctx->memory_pool_size = 1024 * 1024; /* 1MB default */
    new_ctx->flags = 0;

    /* Apply configuration if provided */
    if (config) {
        new_ctx->flags = config->flags;
        if (config->memory_pool_size > 0) {
            new_ctx->memory_pool_size = config->memory_pool_size;
        }
        new_ctx->user_data = config->user_data;
    }

    /* Mark as initialized */
    new_ctx->is_initialized = true;
    set_error(new_ctx, NULL); /* Clear any errors */

    *ctx = new_ctx;
    return POLYCALL_SUCCESS;
}

polycall_status_t polycall_init(polycall_context_t* ctx) {
    return polycall_init_with_config(ctx, NULL);
}

void polycall_cleanup(polycall_context_t* ctx) {
    if (!ctx || !*ctx) {
        return;
    }
    
    struct polycall_context* context = *ctx;
    
    if (!context->is_initialized) {
        set_error(context, "Context not initialized");
        return;
    }
    
    pthread_mutex_lock(&context->lock);
    context->is_initialized = false;
    pthread_mutex_unlock(&context->lock);
    
    pthread_mutex_destroy(&context->lock);
    free(context);
    *ctx = NULL;
}

const char* polycall_get_version(void) {
    return POLYCALL_VERSION;
}

const char* polycall_get_last_error(polycall_context_t ctx) {
    if (!ctx) {
        return "Invalid context";
    }
    return ctx->last_error[0] ? ctx->last_error : "No error";
}

/* Additional core functionality */

polycall_status_t polycall_set_flag(polycall_context_t ctx, unsigned int flag) {
    if (!ctx || !ctx->is_initialized) {
        return POLYCALL_ERROR_NOT_INITIALIZED;
    }
    
    pthread_mutex_lock(&ctx->lock);
    ctx->flags |= flag;
    pthread_mutex_unlock(&ctx->lock);
    
    return POLYCALL_SUCCESS;
}

polycall_status_t polycall_clear_flag(polycall_context_t ctx, unsigned int flag) {
    if (!ctx || !ctx->is_initialized) {
        return POLYCALL_ERROR_NOT_INITIALIZED;
    }
    
    pthread_mutex_lock(&ctx->lock);
    ctx->flags &= ~flag;
    pthread_mutex_unlock(&ctx->lock);
    
    return POLYCALL_SUCCESS;
}

bool polycall_is_initialized(polycall_context_t ctx) {
    return ctx && ctx->is_initialized;
}

void* polycall_get_user_data(polycall_context_t ctx) {
    if (!ctx || !ctx->is_initialized) {
        return NULL;
    }
    return ctx->user_data;
}

polycall_status_t polycall_set_user_data(polycall_context_t ctx, void* data) {
    if (!ctx || !ctx->is_initialized) {
        return POLYCALL_ERROR_NOT_INITIALIZED;
    }
    
    pthread_mutex_lock(&ctx->lock);
    ctx->user_data = data;
    pthread_mutex_unlock(&ctx->lock);
    
    return POLYCALL_SUCCESS;
}
